---
title: "Untitled"
output: html_document
date: "2024-04-05"
---

```{r}
library(readxl)
library(tidyverse)
library(ggplot2)
library (survminer)
library(survival)
library(ggsurvfit)
```



```{r}
works_dataset <- read_csv("wisconsin_breast_cancer.csv")

head(works_dataset)
```


```{r}
colnames(works_dataset)
```
```{r}
summary(works_dataset)
```
Обобщенная статистическая информация по датасету показывает, что пропущенных значений практически нет. Посмотрим более детально: тип данных и есть ли пропуски.

```{r}
str(works_dataset)
```



```{r}
missing_values <- colSums(is.na(works_dataset))
print(missing_values)
```
Задание 1    Создайте регрессионную модель, которая бы описывала связь среднего радиуса опухоли и средней площади (а), среднего периметра (б), средней симметричности (в).
Постройте графики, на которых отразите регрессионную прямую, и прокомментируйте свои находки.

Исследуем связь между radius_mean и area_mean, perimeter_mean, symmetry_mean.
H0: отсутствует связь между средним радиусом опухоли и предикторами (площадью, периметром, симметричностью).
H1: есть связь между средним радиусом опухоли и по крайней мере одним из предикторов (площадью, периметром, симметричностью).
```{r}
# создание регрессионной модели
model <- lm(radius_mean ~ area_mean + perimeter_mean + symmetry_mean, data=works_dataset)

summary(model)
```
p-value < 0.05 для F-статистики  - мы отвергаем нулевую гипотезу и делаем вывод о значимости модели в целом. Так же у нас p-value < 0.05 для каждого предиктора, т.е. мы имеем статистически значимую связь между данным предиктором (area_mean, perimeter_mean, symmetry_mean) и зависимой переменной(radius_mean) в модели


```{r}
ggplot(works_dataset, aes(x = area_mean, y = radius_mean)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  xlab("Средняя площадь") +
  ylab("Средний радиус") +
  ggtitle("Регрессионная модель между средним радиусом и средней площадью")

ggplot(works_dataset, aes(x = perimeter_mean, y = radius_mean)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  xlab("Средняя периметр") +
  ylab("Средний радиус") +
  ggtitle("Регрессионная модель между средним радиусом и средним периметром")

ggplot(works_dataset, aes(x = symmetry_mean, y = radius_mean)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  xlab("Средняя симметрия") +
  ylab("Средний радиус") +
  ggtitle("Регрессионная модель между средним радиусом и средней симметрией")
```




Визуальная оценка графиков модели линейной регресии говорит о том, что для случаев area_mean, perimeter_mean модель хорошо соответствует данным и может быть хорошо использована для прогнозирования radius_mean. На графике модели для  symmetry_mean точки данных имеют большой разброс вокруг линии регрессии, эта модель имеет меньшую предсказательную силу. 
Но в целом, все факторы(в той или иной степени) имеют линейную зависимость с целевой переменной (radius_mean - средний радиус опухоли).

 Оценим нормальность распределения остатков.
```{r}
# визуальная оценка нормальности распределения остатков
qqPlot(residuals(model))
```
В центральной части графика, точки (осатки) практически не отклоняются и находятся в пределах обозначенных интервалов, в начале графика (в левой части) отклонения выражены и распространяются за пределы интервалов.





Задание 2 Пусть колонка с диагнозом принимает следующие значения: злокачественная опухоль — 1, а доброкачественная — 0. Постройте модель, которая бы прогнозировала вероятность возникновения злокачественной опухоли от среднего радиуса (а), средней площади (б), средней текстуры (в).
Постройте графики. Создайте модель, которая бы прогнозировала вероятность возникновения злокачественной опухоли от всех трех перечисленных факторов.


```{r}
# преобразование значений в колонке diagnosis
works_dataset$diagnosis <- ifelse(works_dataset$diagnosis == 'M', 1, 0)

head(works_dataset$diagnosis)
```
```{r}
class(works_dataset$diagnosis)
```

```{r}
# создание матрицы корреляции
cor_matrix <- cor(works_dataset[c("radius_mean", "area_mean", "texture_mean")])

print(cor_matrix)
```
Корреляционная матрица показывает высокую корреляцию между radius_mean и area_mean что не очень хорошо может отразится на предсказательной способности модели логистической регрессии. 

Исследуем связь между radius_mean и area_mean, texture_mean, diagnosis.
H0: отсутствует связь между диагнозом  и предикторами (радиусом, площадью и  текстурой опухоли).
H1: есть связь между диагнозом и по крайней мере одним из предикторов (радиусом, площадью и  текстурой опухоли).
```{r}
# создание логистической модели
logistic_model <- glm(diagnosis ~ radius_mean + area_mean + texture_mean, 
                      data = works_dataset, 
                      family = binomial)

summary(logistic_model)
```
Нулевую гипотезу отклоняем в пользу альтернативной. Для texture_mean p-value < 0.05 - высокая степень статистической значимости , что говорит о том, что этот предиктор является важным для модели.
Для  radius_mean и area_mean p-value > 0.05, эти предикторы не имеют влияния на вероятность наличия злокачественной опухоли.
К тому же если посмотреть на коэффициенты, которые, отображают величину и направление влияния каждого предиктора на вероятность наличия злокачественной опухоли. Положительный коэффициент для texture_mean (0.20911) означает, что увеличение среднего значения текстуры повышает вероятность наличия злокачественной опухоли.

Для более наглядной оценки модели можно вычислить экспоненты коэффициентов, которые  представляют собой отношение вероятностей (отношение шансов),
```{r}
exp(coefficients(logistic_model))
```



```{r}
# График
ggplot(works_dataset, aes(x = radius_mean, y = diagnosis)) +
  geom_point() +
  geom_smooth(method = "glm", method.args = list(family = "binomial")) +
  labs(x = "Radius Mean", y = "Predicted Probability of Diagnosis") +
  theme_bw()
```
```{r}
# График
ggplot(works_dataset, aes(x = area_mean, y = diagnosis)) +
  geom_point() +
  geom_smooth(method = "glm", method.args = list(family = "binomial")) +
  labs(x = "Area mean", y = "Predicted Probability of Diagnosis") +
  theme_bw()
```

```{r}
# Создание графика для переменной radius_mean
ggplot(works_dataset, aes(x = texture_mean, y = diagnosis)) +
  geom_point() +
  geom_smooth(method = "glm", method.args = list(family = "binomial")) +
  labs(x = "Texture mean", y = "Diagnosis") +
  theme_bw()
```






Задание 3 Для выполнения этого задания вам понадобится датасет lung, который встроен в пакет survival.
Создайте переменную event, в которой отразите наличие или отсутствие (1 или 0) интересующего события — смерти пациента.
Изучите работу функций Surv(), survfit() и ggsurvplot():
Постройте кривые выживаемости в зависимости от пола (на одном графике должны получиться две кривые для каждого пола и таблица числа пациентов, подверженных риску (at risk) под ним). Поясните получившееся значение p-value для лог-рангового теста и опишите наблюдаемые результаты.
    Постройте график кумулятивной функции рисков (cumulative hazard function) для пола. Проинтерпретируйте график.
    С помощью функции coxph() постройте регрессию Кокса и оцените влияние пола на выживаемость. Что вы можете сказать о полученных результатах?



```{r}
library(survival)
```


```{r}
head(lung)
```

`
```{r}
# Создаем переменную event сразу в числовом формате
lung$event <- as.numeric(lung$status == 2)

# Выводим первые несколько строк, чтобы убедиться, что переменная event создана правильно
head(lung)

```



```{r}
print(class(lung$event))

```


Далее для корректной работы нам необходимо произвести цензурирование, т.к. для более правильного отображения информации на графиках выживаемости и нам нужны только события интереса. 

```{r}
# выбор только тех строк, где event равен 1
censored_data <- lung[lung$event == 1, ]

head(censored_data)

```



```{r}
# Оценка кривых выживаемости для каждого пола
fit <- survfit(Surv(time, event) ~ sex, data = lung)

# Построение графика выживаемости
ggsurvplot(fit, data = lung, risk.table = TRUE, conf.int = TRUE, pval = TRUE)
```



```{r}
# Построение графика выживаемости с разделением по полу
ggsurvplot(fit, data = lung, risk.table = TRUE, conf.int = TRUE, pval = TRUE, 
           ggtheme = theme_bw(), # выбор стиля графика (опционально)
           palette = c("blue", "red"), # выбор цветов для мужчин и женщин
           linetype = c(1, 1), # выбор типа линий для каждой группы (опционально)
           break.time.by = 100) # выбор шага по оси времени для большей читаемости
```

H0: кривые выживаемости в группах мужчин и женщин одинаковы.
H1: различия в кривых выживаемости между группами статистически значимы. 

У нас получилось p-value < 0.05 (0,0013) мы отклоняем нулевую гипотезу и считаем различия между группами статистически значимыми.

воспользуемся лог-ранк тестом.  Лог-ранг тест вычисляет статистику теста, которая использует оценки Каплана-Мейера для каждой группы и сравнивает наблюдаемое количество событий с ожидаемым, исходя из нулевой гипотезы о том, что кривые выживаемости для всех групп одинаковы. 
```{r}
survdiff(Surv(time, status) ~ sex, data = lung_2)
```
Мы получаем p-value > 0.05 (= 0.1)`и не можем отвергнуть нулевую гипотезу, т.е. нет статистически значимой разницы в выживаемости между двумя группами(полом).
 

```{r}
# построение графика кумулятивной функции рисков по полу
ggsurvplot(surv_fit, fun = "cumhaz", conf.int = TRUE, risk.table = TRUE)
```
Визуальная оценка графика: пересечение доверительных интервалов двух групп и линии графика - это можно оценить как отсутсвие значимых различий между полом по уровню риска.

 Воспользуемся регрессией Кокса, которая позволяет оценить, как различные предикторы влияют на выживаемость, учитывая другие факторы, и интерпретировать результаты с учётом пропорциональности рисков.

```{r}
# регрессия Кокса
cox <- coxph(Surv(time, status) ~ sex, data = lung_2)
summary(cox)
```
Итак, p-value > 0.05 (= 0.136) - разница между двумя группами по полу статистически незначима



